# 动态规划：分而治之的“最优解”魔法动态规划

**定义**：通过将复杂问题分解为相互重叠的子问题，并缓存子问题的解（记忆化）避免重复计算，最终得到全局最优解。

关键词：子问题、全局最优解

动态规划是一个解题思想，上面的概念有些抽象，换个说法其实就是：将问题拆分成若干子问题，当所有子问题都解决了，最后的问题也就解决了。

## 案例解析

先通过一道斐波那契数列感受一下把问题拆分成若干子问题是怎么样的。

### [斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

> **斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：
>
> ```
> F(0) = 0，F(1) = 1
> F(n) = F(n - 1) + F(n - 2)，其中 n > 1
> ```
>
> 给定 `n` ，请计算 `F(n)` 。

题目已经把解题方法给我们了：**后面的每一项数字都是前面两项数字的和**，即 F(n) = F(n - 1) + F(n - 2)，所以 只需要知道 F(n - 1) 和 F(n - 2)，就可以得到 F(n)。以此类推：

```
F(n - 1) = F(n - 2) + F(n - 3)
F(n - 2) = F(n - 3) + F(n - 4)
...
F(2) = F(1) + F(1)
F(1) = 1
F(0) = 1
```

这里的：`F(n - 1) = F(n - 2) + F(n - 3)`、`F(n - 2) = F(n - 3) + F(n - 4)` 就是一个一个的待解决的子问题。而已经解决的子问题是：`F(0) = 0，F(1) = 1`。因此，我们可以从0出发，计算出`F(0)、F(1)、F(2)...`，最后就可以求出 F(n)了。

#### 代码实现：

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var fib = function(n) {
    const F = []
    F[0] = 0
    F[1] = 1

    for(let i = 2; i <= n; i++) {
        F[i] = F[i-1] + F[i-2]
    }

    return F[n]
};
```

#### 复杂度分析


|    **维度**    |              **分析**              |
| :------------: | :--------------------------------: |
| **时间复杂度** |      O(n)，只需遍历一次数组。      |
| **空间复杂度** | O(n)，需要一个数组来存储中间结果。 |

### ****[爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

> 假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。
>
> 每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？
>
> **示例 1：**
>
> <pre><strong>输入：</strong>n = 2
> <strong>输出：</strong>2
> <strong>解释：</strong>有两种方法可以爬到楼顶。
> 1. 1 阶 + 1 阶
> 2. 2 阶</pre>
>
> **示例 2：**
>
> <pre><strong>输入：</strong>n = 3
> <strong>输出：</strong>3
> <strong>解释：</strong>有三种方法可以爬到楼顶。
> 1. 1 阶 + 1 阶 + 1 阶
> 2. 1 阶 + 2 阶
> 3. 2 阶 + 1 阶
> </pre>

#### 思路分析

有了前面的斐波那契数列做铺垫，这道爬楼梯就好理解很多了。

我们约定爬到 n 阶的方法有 f(n) 种。题目要求：「每次你可以爬 `1` 或 `2` 个台阶」。我们换一个思路：【上楼梯】 转变成【下楼梯】。

站在台阶 n 上面往下只有两种可能：

1. 往下走`1`个台阶 - 到达 `n - 1` 阶
2. 往下走`2`个台阶 - 到达 `n - 2` 阶

现在我们已经知道爬到 n - 1 阶的方法有 f(n - 1) 种，爬到 n - 2 阶的方法有 f(n - 2) 种，那么比较容易得出以下的关系：

```javascript
f(n) = f(n - 1) + f(n - 2)
```

这个公式跟斐波那契数列是完全一样的，斐波那契数列的规律是：后面的每一项数字都是前面两项数字的和，而爬楼梯的规律是：爬到 n 阶的方法是前面 n - 1 阶和 n - 2  阶的方法之和。

如果这里一下子没绕过来，可以再试着反过来理解一下：

到达第 1 阶楼梯只有 1 种方法，因为只有一个台阶可爬，到达第 2 阶楼梯只有 2 种方法，分别是：

1. 每次爬一步
2. 一次爬两步

也就是：

```js
f(1) = 1   
f(2) = 2
```

根据上面提到的“下楼梯”，再延伸一下可以得出：台阶3 往下走的方法有 3 种`：f(3) = f(2) + f(1) = 3`。

现在我们已经解决了子问题 f(1) 和 子问题 f(2)，那么我们从台阶 3  出发，一直往上爬，就可以算出 f(n)。

#### 代码实现

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
   // dp 是 dynamic programming 的缩写
    const dp = []
    dp[1] = 1
    dp[2] = 2

    for(let i = 3; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2]
    }

    return dp[n]
};
```

#### 复杂度分析


|    **维度**    |                        **分析**                        |
| :------------: | :----------------------------------------------------: |
| **时间复杂度** |   O(n)，每个字符仅遍历一次，入栈/出栈操作均为 O(1)。   |
| **空间复杂度** | O(n)，最坏情况下栈存储所有左括号（如输入全为左括号）。 |

### [零钱兑换](https://leetcode.cn/problems/coin-change/)

> 给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。
>
> 计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。
>
> 你可以认为每种硬币的数量是无限的。
>
> **示例1**：
>
> 输入：coins = [1, 2, 5], amount = 11
>
> 输出：3
>
> 解释：11 = 5 + 5 + 1
>
> **示例2**：
>
> 输入：coins = [2], amount = 3
>
> 输出：-1
>
> **示例3**：
>
> 输入：coins = [1], amount = 0
>
> 输出：-1

#### 问题分析：

* 目标：用最少数量的硬币凑出目标金额
* 约束：硬币可以重复使用
* 特殊情况：无法凑出时返回-1

我们要找到的是目标金额 amount 所需的最少硬币个数，至于需要的是哪些面额的硬币完全不需要关心。

假设硬币面额数组是 `coins =[c₁, c₂, ..., cₙ]`，每个硬币可以用无数次。

#### 推导过程

我们定义 `dp[i]` 为：组成金额 `i` 所需的最小硬币数，终极目标是求 `dp[amount]`。

假设目前的 `amount` 是 `24`，反过来推导一下：

* 如果从 `24` 中拿走一个硬币 `c₁`，那么 `dp[24- c₁]`就是组成金额`24- c₁` 所需要的最小硬币数。
* `24 - c₁` 如果加上这个硬币 `c₁`，金额又等于 `24` 了，硬币数就是 `dp[24-c₁]+1`
* 也就是 `dp[24] = dp[24-c₁]+1`

总结一下，已知硬币面额数组是 `coins =[c₁, c₂, ..., cₙ]`，金额是 `24`，可以得出：

`dp[24] = Math.min(dp[24-c₁], dp[24-c₂],...dp[24-cₙ])`

重点理解一下这个公式，再配合代码应该就可以理解解题过程了。

#### 代码实现

```javascript

/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function(coins, amount) {
    const dp = []
    // 组成金额 0 不需要硬币
    dp[0] = 0

    for(let i = 1; i <= amount; i++) {
        // 表示暂时无法组成，后续通过比较更新。也是为了后面判断是否应该返回-1
        dp[i] = Infinity

        for(let j = 0; j < coins.length; j++) {
            // 对于金额i, 只有 coin ≤ i，才可以用这枚硬币
            const coin = coins[j]
            if(i - coin >= 0) {
                dp[i] = Math.min(dp[i], dp[i-coin]+1)
            }
        }
    }

    return dp[amount] === Infinity ? -1 : dp[amount]
};
```

#### 复杂度分析


|    **维度**    |              **分析**              |
| :------------: | :---------------------------------: |
| **时间复杂度** | O(S×n)，其中S是金额，n是硬币种类数 |
| **空间复杂度** |         O(S)，dp数组的大小         |
